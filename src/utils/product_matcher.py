"""
ProductMatcher - thin layer over the processed website index.

This lets the API and chatbot discover products using the
`data/processed/website_index.json` file that is already generated by
the scraping/processing pipeline.
"""

from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, List, Tuple, Any, Optional


class ProductMatcher:
    """
    Load product documents from `website_index.json` and provide simple
    lookup / matching helpers.

    The public surface is shaped to satisfy the existing chatbot and API
    code (`match_products`, `get_product_by_id`, etc.).
    """

    def __init__(self, index_path: Optional[Path] = None) -> None:
        if index_path is None:
            index_path = Path(__file__).parent.parent.parent / "data" / "processed" / "website_index.json"

        self.index_path = index_path
        self.product_index: Dict[str, Dict[str, Any]] = {}

        if self.index_path.exists():
            with open(self.index_path, "r", encoding="utf-8") as f:
                raw = json.load(f)
        else:
            raw = {}

        # Normalise into a friendlier structure
        for doc_id, doc in raw.items():
            if doc.get("type") != "product":
                continue

            product_id = doc_id  # use full doc_id as stable ID
            item = {
                "product_id": product_id,
                "doc_id": doc_id,
                "name": doc.get("title") or "",
                "category_name": doc.get("category") or "",
                "sub_category_name": doc.get("subcategory") or "",
                "url": doc.get("url"),
            }
            self.product_index[product_id] = item

    # ------------------------------------------------------------------ #
    # Public API used by chatbot / FastAPI
    # ------------------------------------------------------------------ #
    def match_products(self, query: str, top_k: int = 3) -> List[Tuple[float, int, Dict[str, Any]]]:
        """
        Very simple scoring based on presence of query terms in the
        product name and category. Returns a list of tuples:
        (score, dummy_rank, product_dict)
        so existing callers can use p[2] as the product payload.
        """
        if not query:
            return []

        q = query.lower()
        scored: List[Tuple[float, int, Dict[str, Any]]] = []

        for product in self.product_index.values():
            name = product.get("name", "").lower()
            cat = product.get("category_name", "").lower()
            sub = product.get("sub_category_name", "").lower()

            score = 0.0
            if q in name:
                score += 2.0
            if q in cat or q in sub:
                score += 1.0

            # Fallback: token overlap
            if score == 0.0:
                tokens = set(q.split())
                if tokens & set(name.split()):
                    score += 1.0

            if score > 0.0:
                scored.append((score, 0, product))

        scored.sort(key=lambda t: t[0], reverse=True)
        return scored[:top_k]

    def get_product_by_id(self, product_id: str) -> Optional[Dict[str, Any]]:
        return self.product_index.get(product_id)

    def get_products_by_category(self, category: str) -> List[Dict[str, Any]]:
        cat = (category or "").lower()
        return [p for p in self.product_index.values() if p.get("category_name", "").lower() == cat]

    def get_related_products(self, product_id: str, top_k: int = 3) -> List[Dict[str, Any]]:
        """
        Naive "related" logic: products in the same category/subcategory
        (excluding the seed product).
        """
        base = self.get_product_by_id(product_id)
        if not base:
            return []

        cat = base.get("category_name", "").lower()
        sub = base.get("sub_category_name", "").lower()

        related: List[Dict[str, Any]] = []
        for p in self.product_index.values():
            if p["product_id"] == product_id:
                continue
            if p.get("category_name", "").lower() == cat and p.get("sub_category_name", "").lower() == sub:
                related.append(p)

        return related[:top_k]
