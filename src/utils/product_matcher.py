"""
ProductMatcher - thin layer over the processed website index.

This lets the API and chatbot discover products using the
`data/processed/website_index.json` file that is already generated by
the scraping/processing pipeline.
"""

from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, List, Tuple, Any, Optional


class ProductMatcher:
    """
    Load product documents from `website_index.json` and provide simple
    lookup / matching helpers.

    The public surface is shaped to satisfy the existing chatbot and API
    code (`match_products`, `get_product_by_id`, etc.).
    """

    def __init__(self, index_path: Optional[Path] = None) -> None:
        if index_path is None:
            index_path = Path(__file__).parent.parent.parent / "data" / "processed" / "website_index.json"

        self.index_path = index_path
        self.product_index: Dict[str, Dict[str, Any]] = {}
        # Aliases that the API can accept (slug, category/subcategory/slug, etc.) â†’ doc_id
        self._alias_to_doc_id: Dict[str, str] = {}

        if self.index_path.exists():
            with open(self.index_path, "r", encoding="utf-8") as f:
                raw = json.load(f)
        else:
            raw = {}

        def _product_key_from_doc_id(doc_id: str) -> str:
            """
            Extract "category/subcategory/slug" from:
              website:product:category/subcategory/slug
            """
            prefix = "website:product:"
            if not doc_id or not doc_id.startswith(prefix):
                return ""
            return doc_id[len(prefix) :].strip("/")

        def _slug_from_product_key(product_key: str) -> str:
            if not product_key:
                return ""
            return product_key.strip("/").split("/")[-1]

        # Pre-count slugs so we only alias unique slugs globally.
        slug_counts: Dict[str, int] = {}
        for _doc_id, _doc in raw.items():
            if _doc.get("type") != "product":
                continue
            product_key = (
                (_doc.get("product_key") or "").strip()
                or (_doc.get("product_id") or "").strip()  # not present in website_index.json, but may exist in other indexes
                or _product_key_from_doc_id(_doc_id)
            )
            slug = _slug_from_product_key(product_key)
            if slug:
                slug_counts[slug] = slug_counts.get(slug, 0) + 1

        # Normalise into a friendlier structure
        for doc_id, doc in raw.items():
            if doc.get("type") != "product":
                continue

            # Use full doc_id as stable internal ID for RAG filtering and lookups
            product_id = doc_id
            category = (doc.get("category") or "").strip()
            subcategory = (doc.get("subcategory") or "").strip()
            # website_index.json does not include a slug field; derive from doc_id when missing.
            product_key = _product_key_from_doc_id(doc_id)
            slug = _slug_from_product_key(product_key)

            # If the doc_id wasn't in the expected format, fall back to category/subcategory + any available slug.
            if not product_key:
                slug_fallback = (doc.get("product_id") or "").strip()
                if category and subcategory and slug_fallback:
                    product_key = f"{category}/{subcategory}/{slug_fallback}"
                    slug = slug_fallback
            item = {
                "product_id": product_id,
                "doc_id": doc_id,
                # Friendly identifiers for frontend usage
                "slug": slug,
                "product_key": product_key,  # e.g. "personal/insure/serenicare"
                "name": doc.get("title") or "",
                "category_name": doc.get("category") or "",
                "sub_category_name": doc.get("subcategory") or "",
                "url": doc.get("url"),
            }
            self.product_index[product_id] = item

            # Register aliases for resolving friendly IDs to doc_id
            self._alias_to_doc_id[doc_id] = doc_id
            if product_key:
                self._alias_to_doc_id[product_key] = doc_id
                self._alias_to_doc_id[f"website:product:{product_key}"] = doc_id
            if slug and slug_counts.get(slug, 0) == 1:
                # Only alias a bare slug when it's globally unique to avoid collisions.
                self._alias_to_doc_id[slug] = doc_id

    # ------------------------------------------------------------------ #
    # Public API used by chatbot / FastAPI
    # ------------------------------------------------------------------ #
    def match_products(self, query: str, top_k: int = 3) -> List[Tuple[float, int, Dict[str, Any]]]:
        """
        Very simple scoring based on presence of query terms in the
        product name and category. Returns a list of tuples:
        (score, dummy_rank, product_dict)
        so existing callers can use p[2] as the product payload.
        """
        if not query:
            return []

        q = query.lower()
        scored: List[Tuple[float, int, Dict[str, Any]]] = []

        for product in self.product_index.values():
            name = product.get("name", "").lower()
            cat = product.get("category_name", "").lower()
            sub = product.get("sub_category_name", "").lower()

            score = 0.0
            if q in name:
                score += 2.0
            if q in cat or q in sub:
                score += 1.0

            # Fallback: token overlap
            if score == 0.0:
                tokens = set(q.split())
                if tokens & set(name.split()):
                    score += 1.0

            if score > 0.0:
                scored.append((score, 0, product))

        scored.sort(key=lambda t: t[0], reverse=True)
        return scored[:top_k]

    def get_product_by_id(self, product_id: str) -> Optional[Dict[str, Any]]:
        return self.product_index.get(product_id)

    def resolve_doc_id(self, product_id_or_key: str) -> Optional[str]:
        """
        Resolve a frontend-friendly product identifier to the internal doc_id.

        Accepted inputs:
        - Full doc_id: "website:product:personal/insure/serenicare"
        - Product key: "personal/insure/serenicare"
        - Bare slug (only if unique): "serenicare"
        """
        key = (product_id_or_key or "").strip()
        if not key:
            return None
        return self._alias_to_doc_id.get(key)

    def get_public_id(self, doc_id: str) -> Optional[str]:
        """Return the short product_key for a given internal doc_id."""
        item = self.product_index.get(doc_id)
        if not item:
            return None
        return item.get("product_key") or None

    def get_products_by_category(self, category: str) -> List[Dict[str, Any]]:
        cat = (category or "").lower()
        return [p for p in self.product_index.values() if p.get("category_name", "").lower() == cat]

    def get_related_products(self, product_id: str, top_k: int = 3) -> List[Dict[str, Any]]:
        """
        Naive "related" logic: products in the same category/subcategory
        (excluding the seed product).
        """
        base = self.get_product_by_id(product_id)
        if not base:
            return []

        cat = base.get("category_name", "").lower()
        sub = base.get("sub_category_name", "").lower()

        related: List[Dict[str, Any]] = []
        for p in self.product_index.values():
            if p["product_id"] == product_id:
                continue
            if p.get("category_name", "").lower() == cat and p.get("sub_category_name", "").lower() == sub:
                related.append(p)

        return related[:top_k]
