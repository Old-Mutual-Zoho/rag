"""
Lightweight in-memory PostgresDB replacement for local development.

This provides a minimal subset of the interface expected by the API and
chatbot flows so the system can run without a real database. It is NOT
intended for production use.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional
import uuid


@dataclass
class User:
    id: str
    phone_number: str
    kyc_completed: bool = False


@dataclass
class Conversation:
    id: str
    user_id: str
    mode: str
    created_at: datetime = field(default_factory=datetime.utcnow)
    ended_at: Optional[datetime] = None


@dataclass
class Message:
    id: str
    conversation_id: str
    role: str
    content: str
    metadata: Dict[str, Any]
    timestamp: datetime = field(default_factory=datetime.utcnow)


@dataclass
class Quote:
    id: str
    user_id: str
    product_id: str
    product_name: str
    premium_amount: float
    sum_assured: Optional[float]
    underwriting_data: Dict[str, Any]
    pricing_breakdown: Optional[Dict[str, Any]] = None
    status: str = "pending"
    generated_at: datetime = field(default_factory=datetime.utcnow)
    valid_until: datetime = field(default_factory=lambda: datetime.utcnow() + timedelta(days=30))


@dataclass
class PersonalAccidentApplication:
    id: str
    user_id: str
    status: str = "in_progress"
    personal_details: Dict[str, Any] = field(default_factory=dict)
    next_of_kin: Dict[str, Any] = field(default_factory=dict)
    previous_pa_policy: Dict[str, Any] = field(default_factory=dict)
    physical_disability: Dict[str, Any] = field(default_factory=dict)
    risky_activities: Dict[str, Any] = field(default_factory=dict)
    coverage_plan: Dict[str, Any] = field(default_factory=dict)
    national_id_upload: Dict[str, Any] = field(default_factory=dict)
    quote_id: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)


@dataclass
class TravelInsuranceApplication:
    id: str
    user_id: str
    status: str = "in_progress"
    selected_product: Dict[str, Any] = field(default_factory=dict)
    about_you: Dict[str, Any] = field(default_factory=dict)
    travel_party_and_trip: Dict[str, Any] = field(default_factory=dict)
    data_consent: Dict[str, Any] = field(default_factory=dict)
    travellers: List[Dict[str, Any]] = field(default_factory=list)
    emergency_contact: Dict[str, Any] = field(default_factory=dict)
    bank_details: Dict[str, Any] = field(default_factory=dict)
    passport_upload: Dict[str, Any] = field(default_factory=dict)
    quote_id: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)


@dataclass
class SerenicareApplication:
    id: str
    user_id: str
    status: str = "in_progress"
    cover_personalization: Dict[str, Any] = field(default_factory=dict)
    optional_benefits: List[str] = field(default_factory=list)
    medical_conditions: Dict[str, Any] = field(default_factory=dict)
    plan_option: Dict[str, Any] = field(default_factory=dict)
    about_you: Dict[str, Any] = field(default_factory=dict)
    quote_id: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)


@dataclass
class AgentHandoffLead:
    id: str
    user_id: str
    status: str = "new"
    product_name: Optional[str] = None
    product_url: Optional[str] = None
    contact_details: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.utcnow)


class PostgresDB:
    """
    In-memory standâ€‘in for a Postgres-backed data access layer.

    Methods are intentionally simple and only support what the current
    API and chatbot flows require.
    """

    def __init__(self) -> None:
        self._users: Dict[str, User] = {}
        self._users_by_phone: Dict[str, str] = {}
        self._conversations: Dict[str, Conversation] = {}
        self._messages: List[Message] = []
        self._quotes: Dict[str, Quote] = {}
        # Personal Accident applications
        self._pa_applications: Dict[str, PersonalAccidentApplication] = {}
        # Travel Insurance applications
        self._travel_applications: Dict[str, TravelInsuranceApplication] = {}
        # Serenicare applications
        self._serenicare_applications: Dict[str, SerenicareApplication] = {}
        # Agent handoff leads
        self._agent_handoff_leads: Dict[str, AgentHandoffLead] = {}

    # ------------------------------------------------------------------ #
    # Schema / lifecycle
    # ------------------------------------------------------------------ #
    def create_tables(self) -> None:
        """
        No-op for the in-memory implementation. Kept for compatibility
        with the startup hook in `src/api/main.py`.
        """
        return None

    # ------------------------------------------------------------------ #
    # Users
    # ------------------------------------------------------------------ #
    def get_or_create_user(self, phone_number: str) -> User:
        if phone_number in self._users_by_phone:
            return self._users[self._users_by_phone[phone_number]]

        user_id = str(uuid.uuid4())
        user = User(id=user_id, phone_number=phone_number, kyc_completed=False)
        self._users[user_id] = user
        self._users_by_phone[phone_number] = user_id
        return user

    def get_user_by_phone(self, phone_number: str) -> Optional[User]:
        user_id = self._users_by_phone.get(phone_number)
        if not user_id:
            return None
        return self._users.get(user_id)

    def get_user_by_id(self, user_id: str) -> Optional[User]:
        return self._users.get(user_id)

    # ------------------------------------------------------------------ #
    # Conversations & messages
    # ------------------------------------------------------------------ #
    def create_conversation(self, user_id: str, mode: str) -> Conversation:
        conv_id = str(uuid.uuid4())
        conv = Conversation(id=conv_id, user_id=user_id, mode=mode)
        self._conversations[conv_id] = conv
        return conv

    def add_message(
        self,
        conversation_id: str,
        role: str,
        content: str,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Message:
        msg = Message(
            id=str(uuid.uuid4()),
            conversation_id=conversation_id,
            role=role,
            content=content,
            metadata=metadata or {},
        )
        self._messages.append(msg)
        return msg

    def get_conversation_history(
        self,
        conversation_id: str,
        limit: int = 50,
    ) -> List[Message]:
        msgs = [m for m in self._messages if m.conversation_id == conversation_id]
        # Return newest first, API reverses again where needed
        msgs.sort(key=lambda m: m.timestamp, reverse=True)
        return msgs[:limit]

    # ------------------------------------------------------------------ #
    # Quotes
    # ------------------------------------------------------------------ #
    def create_quote(
        self,
        *,
        user_id: str,
        product_id: str,
        premium_amount: Any,
        sum_assured: Any = None,
        underwriting_data: Optional[Dict[str, Any]] = None,
        pricing_breakdown: Optional[Dict[str, Any]] = None,
        product_name: Optional[str] = None,
    ) -> Quote:
        quote_id = str(uuid.uuid4())
        quote = Quote(
            id=quote_id,
            user_id=user_id,
            product_id=product_id,
            product_name=product_name or product_id,
            premium_amount=float(premium_amount or 0.0),
            sum_assured=float(sum_assured) if sum_assured is not None else None,
            underwriting_data=underwriting_data or {},
            pricing_breakdown=pricing_breakdown,
        )
        self._quotes[quote_id] = quote
        return quote

    def get_quote(self, quote_id: str) -> Optional[Quote]:
        return self._quotes.get(str(quote_id))

    # ------------------------------------------------------------------ #
    # Personal Accident application persistence
    # ------------------------------------------------------------------ #
    def create_pa_application(self, user_id: str, initial_data: Optional[Dict[str, Any]] = None) -> PersonalAccidentApplication:
        app_id = str(uuid.uuid4())
        data = initial_data or {}
        app = PersonalAccidentApplication(
            id=app_id,
            user_id=user_id,
            personal_details=data.get("personal_details", {}),
            next_of_kin=data.get("next_of_kin", {}),
            previous_pa_policy=data.get("previous_pa_policy", {}),
            physical_disability=data.get("physical_disability", {}),
            risky_activities=data.get("risky_activities", {}),
            coverage_plan=data.get("coverage_plan", {}),
            national_id_upload=data.get("national_id_upload", {}),
            quote_id=data.get("quote_id"),
        )
        self._pa_applications[app_id] = app
        return app

    def get_pa_application(self, app_id: str) -> Optional[PersonalAccidentApplication]:
        return self._pa_applications.get(str(app_id))

    def update_pa_application(self, app_id: str, updates: Dict[str, Any]) -> Optional[PersonalAccidentApplication]:
        app = self.get_pa_application(app_id)
        if not app:
            return None
        # Merge updates into the dataclass fields where appropriate
        for k, v in updates.items():
            if hasattr(app, k):
                setattr(app, k, v)
        app.updated_at = datetime.utcnow()
        self._pa_applications[app_id] = app
        return app

    def delete_pa_application(self, app_id: str) -> bool:
        if app_id in self._pa_applications:
            del self._pa_applications[app_id]
            return True
        return False

    def list_pa_applications(
        self,
        user_id: Optional[str] = None,
        order_by: str = "created_at",
        descending: bool = True,
    ) -> List[PersonalAccidentApplication]:
        apps = list(self._pa_applications.values())
        if user_id:
            apps = [a for a in apps if a.user_id == user_id]
        orderable = {
            "id": lambda a: a.id,
            "user_id": lambda a: a.user_id,
            "status": lambda a: a.status,
            "created_at": lambda a: a.created_at,
            "updated_at": lambda a: a.updated_at,
        }
        key_fn = orderable.get(order_by) or orderable["created_at"]
        apps.sort(key=key_fn, reverse=descending)
        return apps

    # ------------------------------------------------------------------ #
    # Travel Insurance application persistence
    # ------------------------------------------------------------------ #
    def create_travel_application(self, user_id: str, initial_data: Optional[Dict[str, Any]] = None) -> TravelInsuranceApplication:
        app_id = str(uuid.uuid4())
        data = initial_data or {}
        app = TravelInsuranceApplication(
            id=app_id,
            user_id=user_id,
            selected_product=data.get("selected_product", {}),
            about_you=data.get("about_you", {}),
            travel_party_and_trip=data.get("travel_party_and_trip", {}),
            data_consent=data.get("data_consent", {}),
            travellers=data.get("travellers", []),
            emergency_contact=data.get("emergency_contact", {}),
            bank_details=data.get("bank_details", {}),
            passport_upload=data.get("passport_upload", {}),
            quote_id=data.get("quote_id"),
        )
        self._travel_applications[app_id] = app
        return app

    def get_travel_application(self, app_id: str) -> Optional[TravelInsuranceApplication]:
        return self._travel_applications.get(str(app_id))

    def update_travel_application(self, app_id: str, updates: Dict[str, Any]) -> Optional[TravelInsuranceApplication]:
        app = self.get_travel_application(app_id)
        if not app:
            return None
        for k, v in updates.items():
            if hasattr(app, k):
                setattr(app, k, v)
        app.updated_at = datetime.utcnow()
        self._travel_applications[app_id] = app
        return app

    def delete_travel_application(self, app_id: str) -> bool:
        if app_id in self._travel_applications:
            del self._travel_applications[app_id]
            return True
        return False

    def list_travel_applications(
        self,
        user_id: Optional[str] = None,
        order_by: str = "created_at",
        descending: bool = True,
    ) -> List[TravelInsuranceApplication]:
        apps = list(self._travel_applications.values())
        if user_id:
            apps = [a for a in apps if a.user_id == user_id]
        orderable = {
            "id": lambda a: a.id,
            "user_id": lambda a: a.user_id,
            "status": lambda a: a.status,
            "created_at": lambda a: a.created_at,
            "updated_at": lambda a: a.updated_at,
        }
        key_fn = orderable.get(order_by) or orderable["created_at"]
        apps.sort(key=key_fn, reverse=descending)
        return apps

    # ------------------------------------------------------------------ #
    # Serenicare application persistence
    # ------------------------------------------------------------------ #
    def create_serenicare_application(self, user_id: str, initial_data: Optional[Dict[str, Any]] = None) -> SerenicareApplication:
        app_id = str(uuid.uuid4())
        data = initial_data or {}
        app = SerenicareApplication(
            id=app_id,
            user_id=user_id,
            cover_personalization=data.get("cover_personalization", {}),
            optional_benefits=data.get("optional_benefits", []),
            medical_conditions=data.get("medical_conditions", {}),
            plan_option=data.get("plan_option", {}),
            about_you=data.get("about_you", {}),
            quote_id=data.get("quote_id"),
        )
        self._serenicare_applications[app_id] = app
        return app

    def get_serenicare_application(self, app_id: str) -> Optional[SerenicareApplication]:
        return self._serenicare_applications.get(str(app_id))

    def update_serenicare_application(self, app_id: str, updates: Dict[str, Any]) -> Optional[SerenicareApplication]:
        app = self.get_serenicare_application(app_id)
        if not app:
            return None
        for k, v in updates.items():
            if hasattr(app, k):
                setattr(app, k, v)
        app.updated_at = datetime.utcnow()
        self._serenicare_applications[app_id] = app
        return app

    def delete_serenicare_application(self, app_id: str) -> bool:
        if app_id in self._serenicare_applications:
            del self._serenicare_applications[app_id]
            return True
        return False

    def list_serenicare_applications(
        self,
        user_id: Optional[str] = None,
        order_by: str = "created_at",
        descending: bool = True,
    ) -> List[SerenicareApplication]:
        apps = list(self._serenicare_applications.values())
        if user_id:
            apps = [a for a in apps if a.user_id == user_id]
        orderable = {
            "id": lambda a: a.id,
            "user_id": lambda a: a.user_id,
            "status": lambda a: a.status,
            "created_at": lambda a: a.created_at,
            "updated_at": lambda a: a.updated_at,
        }
        key_fn = orderable.get(order_by) or orderable["created_at"]
        apps.sort(key=key_fn, reverse=descending)
        return apps

    # ------------------------------------------------------------------ #
    # Agent handoff leads persistence
    # ------------------------------------------------------------------ #
    def create_agent_handoff_lead(self, user_id: str, data: Optional[Dict[str, Any]] = None) -> AgentHandoffLead:
        lead_id = str(uuid.uuid4())
        d = data or {}
        lead = AgentHandoffLead(
            id=lead_id,
            user_id=user_id,
            status="new",
            product_name=d.get("product_name"),
            product_url=d.get("product_url"),
            contact_details=d,
        )
        self._agent_handoff_leads[lead_id] = lead
        return lead

    def get_agent_handoff_lead(self, lead_id: str) -> Optional[AgentHandoffLead]:
        return self._agent_handoff_leads.get(str(lead_id))

    def list_agent_handoff_leads(
        self,
        user_id: Optional[str] = None,
        status: Optional[str] = None,
        descending: bool = True,
    ) -> List[AgentHandoffLead]:
        leads = list(self._agent_handoff_leads.values())
        if user_id:
            leads = [lead for lead in leads if lead.user_id == user_id]
        if status:
            leads = [lead for lead in leads if lead.status == status]
        leads.sort(key=lambda lead: lead.created_at, reverse=descending)
        return leads
