"""
Real Postgres-backed DB for production when USE_POSTGRES_CONVERSATIONS and DATABASE_URL are set.
Implements the same interface as src.database.postgres (in-memory stub).
"""

from __future__ import annotations

import re
from contextlib import contextmanager
from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import uuid4

from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session, sessionmaker

from src.database.models import (
    Base,
    Conversation,
    Message,
    Quote,
    User,
    PersonalAccidentApplication,
    TravelInsuranceApplication,
    SerenicareApplication,
)


def _normalize_connection_string(s: str) -> str:
    """Strip common mistakes: 'psql \'...\'', extra quotes, whitespace."""
    s = s.strip()
    if re.match(r"^psql\s+", s, re.IGNORECASE):
        s = re.sub(r"^psql\s+", "", s, flags=re.IGNORECASE).strip()
    if len(s) >= 2 and s[0] == s[-1] and s[0] in ("'", '"'):
        s = s[1:-1].strip()
    return s


class PostgresDB:
    """
    Postgres data access using SQLAlchemy. Use when DATABASE_URL is set and
    USE_POSTGRES_CONVERSATIONS=true.
    """

    def __init__(self, connection_string: str) -> None:
        connection_string = _normalize_connection_string(connection_string)
        self.engine = create_engine(connection_string, pool_pre_ping=True, pool_size=5, max_overflow=10)
        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, expire_on_commit=False)

    def create_tables(self) -> None:
        Base.metadata.create_all(bind=self.engine)

    @contextmanager
    def _session(self) -> Session:
        s = self.SessionLocal()
        try:
            yield s
            s.commit()
        except Exception:
            s.rollback()
            raise
        finally:
            s.close()

    # ------------------------------------------------------------------ #
    # Users
    # ------------------------------------------------------------------ #
    def get_or_create_user(self, phone_number: str) -> User:
        with self._session() as s:
            stmt = select(User).where(User.phone_number == phone_number)
            u = s.execute(stmt).scalar_one_or_none()
            if u:
                return u
            u = User(id=str(uuid4()), phone_number=phone_number, kyc_completed=False)
            s.add(u)
            s.flush()
            s.refresh(u)
            return u

    def get_user_by_phone(self, phone_number: str) -> Optional[User]:
        with self._session() as s:
            stmt = select(User).where(User.phone_number == phone_number)
            return s.execute(stmt).scalar_one_or_none()

    def get_user_by_id(self, user_id: str) -> Optional[User]:
        with self._session() as s:
            stmt = select(User).where(User.id == user_id)
            return s.execute(stmt).scalar_one_or_none()

    # ------------------------------------------------------------------ #
    # Conversations & messages
    # ------------------------------------------------------------------ #
    def create_conversation(self, user_id: str, mode: str) -> Conversation:
        with self._session() as s:
            c = Conversation(id=str(uuid4()), user_id=user_id, mode=mode)
            s.add(c)
            s.flush()
            s.refresh(c)
            return c

    def add_message(
        self,
        conversation_id: str,
        role: str,
        content: str,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Message:
        with self._session() as s:
            m = Message(
                id=str(uuid4()),
                conversation_id=conversation_id,
                role=role,
                content=content,
                message_metadata=metadata or {},
            )
            s.add(m)
            s.flush()
            s.refresh(m)
            return m

    def get_conversation_history(self, conversation_id: str, limit: int = 50) -> List[Message]:
        with self._session() as s:
            stmt = (
                select(Message)
                .where(Message.conversation_id == conversation_id)
                .order_by(Message.timestamp.desc())
                .limit(limit)
            )
            return list(s.execute(stmt).scalars().all())

    # ------------------------------------------------------------------ #
    # Quotes
    # ------------------------------------------------------------------ #
    def create_quote(
        self,
        *,
        user_id: str,
        product_id: str,
        premium_amount: Any,
        sum_assured: Any = None,
        underwriting_data: Optional[Dict[str, Any]] = None,
        pricing_breakdown: Optional[Dict[str, Any]] = None,
        product_name: Optional[str] = None,
    ) -> Quote:
        with self._session() as s:
            q = Quote(
                id=str(uuid4()),
                user_id=user_id,
                product_id=product_id,
                product_name=product_name or product_id,
                premium_amount=float(premium_amount or 0.0),
                sum_assured=float(sum_assured) if sum_assured is not None else None,
                underwriting_data=underwriting_data or {},
                pricing_breakdown=pricing_breakdown,
            )
            s.add(q)
            s.flush()
            s.refresh(q)
            return q

    def get_quote(self, quote_id: str) -> Optional[Quote]:
        with self._session() as s:
            stmt = select(Quote).where(Quote.id == str(quote_id))
            return s.execute(stmt).scalar_one_or_none()

    # ------------------------------------------------------------------ #
    # Personal Accident applications
    # ------------------------------------------------------------------ #
    def create_pa_application(self, user_id: str, initial_data: Optional[Dict[str, Any]] = None) -> PersonalAccidentApplication:
        data = initial_data or {}
        with self._session() as s:
            app = PersonalAccidentApplication(
                id=str(uuid4()),
                user_id=user_id,
                status=data.get("status", "in_progress"),
                personal_details=data.get("personal_details", {}),
                next_of_kin=data.get("next_of_kin", {}),
                previous_pa_policy=data.get("previous_pa_policy", {}),
                physical_disability=data.get("physical_disability", {}),
                risky_activities=data.get("risky_activities", {}),
                coverage_plan=data.get("coverage_plan", {}),
                national_id_upload=data.get("national_id_upload", {}),
                quote_id=data.get("quote_id"),
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow(),
            )
            s.add(app)
            s.flush()
            s.refresh(app)
            return app

    def get_pa_application(self, app_id: str) -> Optional[PersonalAccidentApplication]:
        with self._session() as s:
            stmt = select(PersonalAccidentApplication).where(PersonalAccidentApplication.id == str(app_id))
            return s.execute(stmt).scalar_one_or_none()

    def update_pa_application(self, app_id: str, updates: Dict[str, Any]) -> Optional[PersonalAccidentApplication]:
        with self._session() as s:
            stmt = select(PersonalAccidentApplication).where(PersonalAccidentApplication.id == str(app_id))
            app = s.execute(stmt).scalar_one_or_none()
            if not app:
                return None
            for k, v in (updates or {}).items():
                if hasattr(app, k):
                    setattr(app, k, v)
            app.updated_at = datetime.utcnow()
            s.add(app)
            s.flush()
            s.refresh(app)
            return app

    def delete_pa_application(self, app_id: str) -> bool:
        with self._session() as s:
            stmt = select(PersonalAccidentApplication).where(PersonalAccidentApplication.id == str(app_id))
            app = s.execute(stmt).scalar_one_or_none()
            if not app:
                return False
            s.delete(app)
            return True

    def list_pa_applications(
        self,
        user_id: Optional[str] = None,
        order_by: str = "created_at",
        descending: bool = True,
    ) -> List[PersonalAccidentApplication]:
        with self._session() as s:
            stmt = select(PersonalAccidentApplication)
            if user_id:
                stmt = stmt.where(PersonalAccidentApplication.user_id == str(user_id))
            orderable = {
                "id": PersonalAccidentApplication.id,
                "user_id": PersonalAccidentApplication.user_id,
                "status": PersonalAccidentApplication.status,
                "created_at": PersonalAccidentApplication.created_at,
                "updated_at": PersonalAccidentApplication.updated_at,
            }
            col = orderable.get(order_by) or PersonalAccidentApplication.created_at
            stmt = stmt.order_by(col.desc() if descending else col.asc())
            return list(s.execute(stmt).scalars().all())

    # ------------------------------------------------------------------ #
    # Travel Insurance applications
    # ------------------------------------------------------------------ #
    def create_travel_application(self, user_id: str, initial_data: Optional[Dict[str, Any]] = None) -> TravelInsuranceApplication:
        data = initial_data or {}
        with self._session() as s:
            app = TravelInsuranceApplication(
                id=str(uuid4()),
                user_id=user_id,
                status=data.get("status", "in_progress"),
                selected_product=data.get("selected_product", {}),
                about_you=data.get("about_you", {}),
                travel_party_and_trip=data.get("travel_party_and_trip", {}),
                data_consent=data.get("data_consent", {}),
                travellers=data.get("travellers", []),
                emergency_contact=data.get("emergency_contact", {}),
                bank_details=data.get("bank_details", {}),
                passport_upload=data.get("passport_upload", {}),
                quote_id=data.get("quote_id"),
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow(),
            )
            s.add(app)
            s.flush()
            s.refresh(app)
            return app

    def get_travel_application(self, app_id: str) -> Optional[TravelInsuranceApplication]:
        with self._session() as s:
            stmt = select(TravelInsuranceApplication).where(TravelInsuranceApplication.id == str(app_id))
            return s.execute(stmt).scalar_one_or_none()

    def update_travel_application(self, app_id: str, updates: Dict[str, Any]) -> Optional[TravelInsuranceApplication]:
        with self._session() as s:
            stmt = select(TravelInsuranceApplication).where(TravelInsuranceApplication.id == str(app_id))
            app = s.execute(stmt).scalar_one_or_none()
            if not app:
                return None
            for k, v in (updates or {}).items():
                if hasattr(app, k):
                    setattr(app, k, v)
            app.updated_at = datetime.utcnow()
            s.add(app)
            s.flush()
            s.refresh(app)
            return app

    def delete_travel_application(self, app_id: str) -> bool:
        with self._session() as s:
            stmt = select(TravelInsuranceApplication).where(TravelInsuranceApplication.id == str(app_id))
            app = s.execute(stmt).scalar_one_or_none()
            if not app:
                return False
            s.delete(app)
            return True

    def list_travel_applications(
        self,
        user_id: Optional[str] = None,
        order_by: str = "created_at",
        descending: bool = True,
    ) -> List[TravelInsuranceApplication]:
        with self._session() as s:
            stmt = select(TravelInsuranceApplication)
            if user_id:
                stmt = stmt.where(TravelInsuranceApplication.user_id == str(user_id))
            orderable = {
                "id": TravelInsuranceApplication.id,
                "user_id": TravelInsuranceApplication.user_id,
                "status": TravelInsuranceApplication.status,
                "created_at": TravelInsuranceApplication.created_at,
                "updated_at": TravelInsuranceApplication.updated_at,
            }
            col = orderable.get(order_by) or TravelInsuranceApplication.created_at
            stmt = stmt.order_by(col.desc() if descending else col.asc())
            return list(s.execute(stmt).scalars().all())

    # ------------------------------------------------------------------ #
    # Serenicare applications
    # ------------------------------------------------------------------ #
    def create_serenicare_application(self, user_id: str, initial_data: Optional[Dict[str, Any]] = None) -> SerenicareApplication:
        data = initial_data or {}
        with self._session() as s:
            app = SerenicareApplication(
                id=str(uuid4()),
                user_id=user_id,
                status=data.get("status", "in_progress"),
                cover_personalization=data.get("cover_personalization", {}),
                optional_benefits=data.get("optional_benefits", []),
                medical_conditions=data.get("medical_conditions", {}),
                plan_option=data.get("plan_option", {}),
                about_you=data.get("about_you", {}),
                quote_id=data.get("quote_id"),
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow(),
            )
            s.add(app)
            s.flush()
            s.refresh(app)
            return app

    def get_serenicare_application(self, app_id: str) -> Optional[SerenicareApplication]:
        with self._session() as s:
            stmt = select(SerenicareApplication).where(SerenicareApplication.id == str(app_id))
            return s.execute(stmt).scalar_one_or_none()

    def update_serenicare_application(self, app_id: str, updates: Dict[str, Any]) -> Optional[SerenicareApplication]:
        with self._session() as s:
            stmt = select(SerenicareApplication).where(SerenicareApplication.id == str(app_id))
            app = s.execute(stmt).scalar_one_or_none()
            if not app:
                return None
            for k, v in (updates or {}).items():
                if hasattr(app, k):
                    setattr(app, k, v)
            app.updated_at = datetime.utcnow()
            s.add(app)
            s.flush()
            s.refresh(app)
            return app

    def delete_serenicare_application(self, app_id: str) -> bool:
        with self._session() as s:
            stmt = select(SerenicareApplication).where(SerenicareApplication.id == str(app_id))
            app = s.execute(stmt).scalar_one_or_none()
            if not app:
                return False
            s.delete(app)
            return True

    def list_serenicare_applications(
        self,
        user_id: Optional[str] = None,
        order_by: str = "created_at",
        descending: bool = True,
    ) -> List[SerenicareApplication]:
        with self._session() as s:
            stmt = select(SerenicareApplication)
            if user_id:
                stmt = stmt.where(SerenicareApplication.user_id == str(user_id))
            orderable = {
                "id": SerenicareApplication.id,
                "user_id": SerenicareApplication.user_id,
                "status": SerenicareApplication.status,
                "created_at": SerenicareApplication.created_at,
                "updated_at": SerenicareApplication.updated_at,
            }
            col = orderable.get(order_by) or SerenicareApplication.created_at
            stmt = stmt.order_by(col.desc() if descending else col.asc())
            return list(s.execute(stmt).scalars().all())
